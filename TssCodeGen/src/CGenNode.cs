/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

namespace CodeGen
{
    /// <summary> Node.js TSS code generator </summary>
    class CGenNode : CodeGenBase
    {
        public CGenNode(string rootDir) : base(rootDir + @"src\", "TpmExtensions.js.snips") {}

        void WriteAutoGeneratedSourceHeader()
        {
            TpmNamedConstant ver = TpmTypes.LookupConstant("TPM_SPEC_VERSION");
            Write("/* \r\n" +
                    " * Copyright(c) Microsoft Corporation. All rights reserved. \r\n" +
                    " * Licensed under the MIT License. \r\n" +
                    " * See the LICENSE file in the project root for full license information. \r\n" +
                    " */\r\n" +
                    "\r\n" +
                    "/*\r\n" +
                    " * This file is automatically generated from the TPM 2.0 rev. " +
                    (ver.NumericValue / 100.0).ToString("0.00") + " specification documents.\r\n" +
                    " * Do not edit it directly.\r\n" +
                    " */\r\n" +
                    "\r\n");
        }

        internal override void Generate()
        {
            WriteAutoGeneratedSourceHeader();
            Write("import { TpmMarshaller, TpmBuffer } from \"./TpmMarshaller.js\";\r\n" +
                    "import { TpmStructure, ReqStructure, RespStructure, SessEncInfo } from \"./TpmStructure.js\";\r\n" +
                    "\r\n" +
                    "import { Crypto } from \"./Crypt.js\";\r\n" +
                    "\r\n");

            // First generate enums
            foreach (var e in TpmTypes.Get<TpmEnum>())
                GenEnum(e);
            foreach (var b in TpmTypes.Get<TpmBitfield>())
                GenBitfield(b);
            // Then generate unions and structures
            GenUnions();
            foreach (var s in TpmTypes.Get<TpmStruct>())
                GenStruct(s);

            File.WriteAllText(RootDir + "TpmTypes.ts", GeneratedCode.ToString());
            GeneratedCode.Clear();

            // Now generate the TPM methods
            GenCommands();

            File.WriteAllText(RootDir + "Tpm.ts", GeneratedCode.ToString());
            GeneratedCode.Clear();
        }

        void GenEnum(TpmType e, List<TpmNamedConstant> elements)
        {
            WriteComment(e);
            Write($"export enum {e.Name} // {e.UnderlyingType.SpecName}");
            TabIn("{");

            foreach (var elt in elements)
            {
                // Skip TPM_RC.H enumerator (an alias hiding SUCCESS value)
                if (elt.Name == "H")
                    continue;

                string sep = Separator(elt, elements);
                WriteComment(elt);
                Write($"{elt.Name} = {elt.Value}{sep}");

                // Backward compat
                if (elt.Name == "PW")
                {
                    WriteComment("@deprecated Use TPM_RH.PW instead");
                    Write($"RS_PW = {elt.Value},");
                }
                if (sep != "")
                    Write("");
            }
            string type = e is TpmEnum ? "enum" : "bitfield";
            TabOut($"}}; // {type} {e.Name}");
        } // GenEnum()

        void GenEnum(TpmEnum e)
        {
            GenEnum(e, e.Members);
        }

        void GenBitfield(TpmBitfield bf)
        {
            GenEnum(bf, GetBifieldElements(bf));
        }

        /// <summary>
        /// C unions of the TPM spec are translated into TypeScript classes implementing
        /// an interface defining the union 
        /// </summary>
        void GenUnions()
        {
            var unions = TpmTypes.Get<TpmUnion>();

            WriteComment("Base class for TPM union interfaces");
            Write("export interface TpmUnion extends TpmMarshaller {}");

            //
            // Union interfaces definitions
            //
            foreach (TpmUnion u in unions)
            {
                WriteComment(u);
                Write($"export interface {u.Name} extends TpmUnion");
                TabIn("{");
                Write($"GetUnionSelector(): {GetUnionSelectorType(u)};");
                TabOut("}");
            }

            //
            // Union factory
            //
            WriteComment("Holds static factory method for instantiating TPM unions.\n" +
                "Note: A wrapper class is used instead of simply static function solely " +
                "for the sake of uniformity with languages like C# and Java.");
            Write("class UnionFactory");
            TabIn("{");
            WriteComment("Creates specific TPM union member based on the union type and selector (tag) value");
            Write("public static create(unionType: string, selector: TPM_ALG_ID | TPM_CAP | TPM_ST): any");
            TabIn("{");
            Write("switch (unionType) {");
            foreach (TpmUnion u in unions)
            {
                TabIn($"case '{u.Name}':");
                TabIn("switch (selector) {");
                foreach (UnionMember m in u.Members)
                {
                    string newObject = m.Type.IsElementary() ? TargetLang.Null : $"new {m.Type.Name}()";
                    Write($"case {m.SelectorValue.QualifiedName}: return {newObject};");
                }
                TabOut("}", false);  // inner switch
                Write("break;");
                TabOut();
            }
            TabIn("default:");
            Write("throw new Error('UnionFactory.create(): Unknown union type ' + unionType);");
            TabOut("}");  // outer switch
            Write("throw new Error('Unknown selector value ' + selector + ' for union ' + unionType);");
            TabOut("} // create()", false);
            TabOut("} // class UnionFactory");
        } // GenUnions()

        void GenGetUnionSelector(TpmStruct s)
        {
            string selType = GetUnionMemberSelectorInfo(s, out string selVal);
            if (selType != null)
            {
                WriteComment("TpmUnion method");
                Write($"GetUnionSelector(): {selType} {{ return {selVal}; }}");
            }
        }

        public void GenMarshalingMethod(bool dirTo, TpmStruct s)
        {
            var fields = s.MarshalFields;
            if (s.DerivedFrom != null || fields.Count() == 0)
                return;

            string  dir = dirTo ? "to" : "initFrom",
                    proto = $"{dir}Tpm(buf: TpmBuffer): void";

            var marshalOps = dirTo ? GetToTpmFieldsMarshalOps(fields)
                                   : GetFromTpmFieldsMarshalOps(fields);

            WriteComment("TpmMarshaller method");
            if (marshalOps.Count == 1)
            {
                // Lay it out in a single line
                Write($"{proto} {{ {marshalOps[0]}; }}");
            }
            else
            {
                Write(proto);
                TabIn("{");
                foreach (var op in marshalOps)
                    Write($"{op};");
                TabOut("}", false);
            }
        } // GenMarshalingMethod()

        /// <summary>
        /// Structures in C are classes in TypeScript
        /// </summary>
        /// <param name="s"></param>
        void GenStruct(TpmStruct s)
        {
            bool hasBase = s.DerivedFrom != null;
            string className = s.Name;
            string classBases = hasBase ? s.DerivedFrom.Name
                              : !s.IsCmdStruct() ? "TpmStructure"
                              : s.Info.IsRequest() ? "ReqStructure" : "RespStructure";

            // If this struct is not derived from another one and is a member of one or more unions,
            // it must implement the corresponding union interfaces
            if (!s.IsCmdStruct() && !hasBase)
            {
                string unionInterfaces = string.Join(", ", s.ContainingUnions.Select(u => u.Name));
                if (unionInterfaces != "")
                    classBases += " implements " + unionInterfaces;
            }

            // Javadoc comment for the data structure
            WriteComment(s);

            // Class header
            Write($"export class {className} extends {classBases}");
            TabIn("{");

            // In TypeScript, member fields declaration is melded with member-wise constructor
            // that also playe the role of the default one

            //
            // Field defining constructor
            //
            var fields = s.FieldHolder.NonTagFields;
            if (fields.Count() == 0)
                Write("constructor() { super(); }");
            else
            {
                Write("constructor(");
                TabIn();

                // If a non-trivial base class is present, all member fields are contained there,
                // so just pass through the initialization parameters
                string ctrParamQualifier = hasBase ? "" : "public ";
                string baseIntializers = "";
                foreach (var f in fields)
                {
                    // Javadoc comment for the member/constructor parameter.
                    // Add a list of data structures implementing the interface of a union parameters.
                    WriteComment(f);

                    string comma = Separator(f, fields, ", ");
                    Write($"{ctrParamQualifier}{f.Name}: {f.TypeName} = {f.GetInitVal()}{comma}");
                    if (hasBase)
                        baseIntializers += f.Name + comma;
                }
                TabOut($") {{ super({baseIntializers}); }}");

                //
                // Named union tag getters (instead of the corresponding fields in the TPM 2.0 spec)
                //
                foreach (var sel in s.TagFields)
                {
                    if (sel.MarshalType != MarshalType.UnionSelector)
                        continue;

                    var u = (TpmUnion)sel.RelatedUnion.Type;
                    string unionField = ThisMember + sel.RelatedUnion.Name;
                    WriteComment(sel);
                    Write($"get {sel.Name}(): {sel.TypeName} {{ ", false);
                    if (u.NullSelector == null)
                        Write($"return {unionField}.GetUnionSelector(); }}");
                    else
                    {
                        Write($"return {unionField} ? {unionField}.GetUnionSelector()" +
                                                    $" : {u.NullSelector.QualifiedName}; }}");
                    }
                }
            }

            //
            // Union interface: TpmUnion.GetUnionSelector()
            //
            GenGetUnionSelector(s);

            //
            // Marshaling
            //
            GenMarshalingMethod(true, s);
            GenMarshalingMethod(false, s);

            WriteComment("Static marshaling helper");
            Write($"public static fromTpm(buf: TpmBuffer) : {className}");
            TabIn("{");
            Write($"return buf.createObj({className});");
            TabOut("}");

            WriteComment("Static marshaling helper");
            Write($"public static fromBytes(buffer: any) : {className}");
            TabIn("{");
            Write($"return new TpmBuffer(buffer).createObj({className});");
            TabOut("}");

            var info = s.IsCmdStruct() ? s.Info as CmdStructInfo : null;
            if (info != null && (info.NumHandles != 0 || info.SessEncSizeLen != 0))
            {
                if (info.NumHandles != 0)
                {
                    Write($"numHandles(): number {{ return {info.NumHandles}; }}");
                    if (info.IsRequest())
                    {
                        string handles = string.Join(", ", s.Fields.Take(info.NumHandles).Select(f => ThisMember + f.Name));
                        Write($"numAuthHandles(): number {{ return {info.NumAuthHandles}; }}");
                        Write($"getHandles(): TPM_HANDLE[] {{ return [{handles}]; }}");
                    }
                    else
                    {
                        Debug.Assert(info.NumHandles == 1 && info.NumAuthHandles == 0);
                        Write($"getHandle(): TPM_HANDLE {{ return {ThisMember}{s.Fields[0].Name}; }}");
                        Write($"setHandle(h: TPM_HANDLE): void {{ {ThisMember}{s.Fields[0].Name} = h; }}");
                    }
                }
                if (info.SessEncSizeLen != 0)
                {
                    Debug.Assert(info.SessEncValLen != 0);
                    Write("");
                    Write($"sessEncInfo(): SessEncInfo {{ return new SessEncInfo({info.SessEncSizeLen}, {info.SessEncValLen}); }}");
                }
            }

            //
            // Custom members
            //
            InsertSnip(s.Name);

            TabOut($"}} // {className}");
        } // GenStruct()

        void GenCommands()
        {
            WriteAutoGeneratedSourceHeader();
            Write(  "import * as tt from \"./TpmTypes.js\";\r\n" +
                    "import { TpmBase, TpmError } from \"./TpmBase.js\";\r\n" +
                    "import { TpmBuffer } from \"./TpmMarshaller.js\";\r\n" +
                    "\r\n");

            Write($"export class Tpm extends TpmBase");
            TabIn("{");
            foreach (var req in TpmTypes.Get<TpmStruct>().Where(s => s.Info.IsRequest()))
            {
                GenCommand(req);
            }
            TabOut("} // class Tpm", false);
        } // GenCommands()

        void GenCommand(TpmStruct req)
        {
            const string NS = "tt.";
            var resp = GetRespStruct(req);
            var cmdName = GetCommandName(req);
            string respType = NS + resp.Name;
            string cmdCode = NS + "TPM_CC." + cmdName;
            var fields = req.NonTagFields;
            var respFields = resp.NonTagFields;
            if (ForceJustOneReturnParm.Contains(cmdName))
                respFields = respFields.Take(1).ToArray();

            int numOutParms = respFields.Count();
            string returnType = numOutParms == 1 ? NsQualifiedType(respFields[0], NS)
                              : numOutParms == 0 ? "void" : respType;

            // javadoc annotation
            string annotation = req.Comment + eol + eol;
            foreach (var f in fields)
                annotation += GetParamComment(f) + eol;
            annotation += GetReturnComment(respFields);
            WriteComment(annotation);

            // method definition
            string paramList = "";
            string reqStructInitList = "";
            foreach (var f in fields)
            {
                string parmTypeName = NsQualifiedType(f, NS);
                string comma = Separator(f, fields, ", ");
                paramList += f.Name + ": " + parmTypeName + ", ";
                reqStructInitList += f.Name + comma;
            }

            var indent = new string(' ', cmdName.Length + 2);
            string respParams = returnType == null ? "" : "res?: " + returnType;
            if (paramList != "")
            {
                Write($"{cmdName}({paramList}");
                Write($"{indent}continuation: (err: TpmError, {respParams}) => void)");
            }
            else
                Write($"{cmdName}(continuation: (err: TpmError, {respParams}) => void)");
            Write("{");

            TabIn();
            Write($"let req = new {NS}{req.Name}({reqStructInitList});");
            Write($"{ThisMember}dispatchCommand({cmdCode}, req, (respBuf: TpmBuffer): void => {{");
            respType = numOutParms > 0 ? ", " + respType : "";
            Write($"let res = {ThisMember}processResponse(respBuf{respType});");
            string  res = "",
                    resField = "";
            if (numOutParms > 0)
            {
                res = ", res";
                if (numOutParms == 1)
                    resField = $"?.{respFields[0].Name}";
            }
            Write($"setImmediate(continuation, {ThisMember}lastError{res}{resField});  }});");

            TabOut($"}} // {cmdName}()");
        } // GenCommand()

        protected override void WriteComment(string comment, bool wrap = true)
        {
            WriteComment(comment, "/** ", " *  ", "\n */", wrap);
        }
    } // class CGenNode
}
